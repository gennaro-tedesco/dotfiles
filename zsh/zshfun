## ----------------
## custom functions
## ----------------

# mkdir and cd
mkcd() {
	mkdir -p -- "$1" && cd -P -- "$1"
}


# fzf browse files
find_files() {
	IFS=$'\n' files=($(fzf --query="$1" --multi --select-1 --exit-0 --prompt 'files:'))
	[[ -n "$files" ]] && ${EDITOR} "${files[@]}"
}


# fzf browse directories and cd into them
find_dir() {
	local dir
	dir=$(fd -IH -t d 2> /dev/null | fzf --prompt 'folders:' +m --preview-window='right:50%:nohidden:wrap' --preview='exa --tree --level=2 {}') && cd "$dir"
}


# list env variables
list_env() {
	local var
	var=$(printenv | cut -d= -f1 | fzf --prompt 'env:' --preview='printenv {}') \
		&& echo "$var=$(printenv "$var")" \
		&& unset var
}


# list go env variables
list_goenv() {
	local var
	var=$(go env | cut -d= -f1 | fzf --prompt 'env:' --preview='go env {}') \
		&& echo "$var=$(go env "$var")" \
		&& unset var
}


# search regex in current directory
search() {
	[[ $# > 1 ]] && { echo "pass one regex argument only"; return }
	[[ $# -eq 0 ]] && { echo -n "search regex: "; read -r regex} || regex=$1
	local matching_files
	matching_files=$(rg -l ${regex} | fzf --preview="rg '${regex}' {} --color=always -n")
	[[ -n "$matching_files" ]] && ${EDITOR} "${matching_files}" -c/${regex}
}


# replace
replace() {
	[[ ! "$(git rev-parse --is-inside-work-tree 2>/dev/null)" = "true" ]] && { echo "not a git repo"; return }
	echo -n "search regex: "; read -r find_regex
	local matching_files
	matching_files=$(rg -l --count-matches $find_regex)
	[[ -n "$matching_files" ]] && { echo $matching_files | awk 'BEGIN {FS=":"; print}; {printf "\033[36m %s\033[35m %s\033[0m\n", $1,":"$2}; END{print ""}' } || { echo "no matching files"; return }
	echo -n "replace with: "; read -r replace_regex
	[[ -n $replace_regex ]] && echo $matching_files | cut -f1 -d":" | xargs -n 1 -I {} -t sed -i '' "s/$find_regex/$replace_regex/g" {}
}


# paginate help
help() { "$@" --help | bat -l man -p ; }


# preview files
preview_files() {
	local selection
	if [[ -z "$1" ]]; then
		selection="$(echo *(^/) | tr " " "\n" | fzf)" && preview_files "$selection"
		return 0
	fi
	case $1 in
		*.md)
			glow -s ~/.config/glowconfig/customglow.json -p $1;;
		*.json)
			jq '.' -C $1 | less;;
		*.csv)
			vd "$@";;
		*.pdf)
			zathura $1;;
		*)
			bat --theme='Solarized (dark)' --style='header,grid' $1;;
	esac
}


# dvc repro
repro() {
	[[ ! -f "dvc.yaml" ]] && { echo "dvc.yaml not found"; return }
	local stages
	stages=$(dvc stage list --names-only 2>/dev/null | fzf --prompt 'stages:' --preview-window="right:50%:nohidden:wrap" --preview="yq e '.stages.{}' dvc.yaml --colors") \
		&& dvc repro "$stages"
}


# json_diff
json_diff() {
	[[ $# != 2 ]] && { echo "expected two arguments"; return}
	[[ ( $1 != *.json ) || ( $2 != *.json ) ]] && { echo "arguments must be both json files"; return}
	[[ ! -f $1 ]] && { echo "cannot find $1"; return}
	[[ ! -f $2 ]] && { echo "cannot find $2"; return}

	delta =(jq -S . $1) =(jq -S . $2)
}


# preview json files
jqx() {
	[[ ( $# -ne 1 ) || ( $1 != *.json ) ]] && { echo "pass one json file only"; return }

	local json_type="$(jq '.|type' $1)"
	if [[ "$(jq '.|type' $1)" == "\"array\"" ]]
	then
		jq 'keys[]' "$1" |
			fzf \
				--preview "jq '.[{}]' $1 -C" \
				--prompt "array index:" \
				--bind "enter:execute:(jq  '.[{}]' $1 -C | less)"
	else
		jq 'keys[]' "$1" |
			fzf \
				--preview "jq .{} $1 -C" \
				--prompt "keys:" \
				--bind "enter:execute:(jq  .{} $1 -C | less)"
	fi
}

# curl weather
weather() {
	local location
	[[ $# -eq 0 ]] && location="Berlin" || location=$1
	curl wttr.in/${location}\?F
}
