## ----------------
## custom functions
## ----------------

is_git_repo() {
	[ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" = "true" ]
}

# mkdir and cd
mkcd() {
	mkdir -p -- "$1" && cd -P -- "$1"
}

# fzf-lua widget to find files
find_files() {
	zle -I
	command nvim -l "$FZF_LUA_PATH/scripts/cli.lua" files </dev/tty >/dev/tty 2>&1
	zle reset-prompt
}
zle -N find_files

# fzf-lua widget to find git changed files
find_git_files() {
	zle -I
	if ! is_git_repo; then { echo "not a git repo"; return }; fi
	if git diff --quiet; then { echo "no file changes"; return }; fi

	command nvim -l "$FZF_LUA_PATH/scripts/cli.lua" git_status </dev/tty >/dev/tty 2>&1
}
zle -N find_git_files

# fzf-lua widget to grep project
grep_project() {
	zle -I
	command nvim -l "$FZF_LUA_PATH/scripts/cli.lua" grep_project </dev/tty >/dev/tty 2>&1
	zle reset-prompt
}
zle -N grep_project

# fzf browse directories and cd into them
find_dir() {
	local dir
	dir=$(fd -IH -t d -E '.git' 2> /dev/null | fzf  --ghost 'folder name' +m --preview-window='right:50%:nohidden:wrap' --preview='eza --tree --level=2 --color=always {}') && cd "$dir"
}

# list env variables
list_env() {
	local var
	var=$(printenv | cut -d= -f1 | sort | fzf --prompt 'â¯ ' --ghost 'env' --bind='focus:transform-footer:printenv {} __NOVAR__') \
		&& echo "$var=$(printenv "$var")" \
		&& unset var
}

# replace
replace() {
	[[ ! "$(git rev-parse --is-inside-work-tree 2>/dev/null)" = "true" ]] && { echo "not a git repo"; return; }

	local find_regex=$(gum input --prompt="find regex: " --placeholder="find pattern...")
	if [[ -z "$find_regex" ]]; then
		return
	fi
	local matching_files=$(rg -l --count-matches $find_regex | column -s: -t)

	if [[ -n "$matching_files" ]]; then
		gum style --border rounded --foreground "#d33682" --border-foreground "#2aa198" --margin "1 1" --padding "1 1" $matching_files
	else
		echo "no matching files"
		return
	fi

	local replace_regex=$(gum input --prompt="replace regex: " --placeholder="replace pattern...")
	if [[ ! -z "$replace_regex" ]]; then
		gum confirm "replace $find_regex with $replace_regex ?" && \
		echo $matching_files | \
		cut -f1 -d' ' | \
		xargs -n 1 -I {} -t sed -i '' "s/$find_regex/$replace_regex/g" {}
	else
		return
	fi
}

# paginate help
help() { "$@" --help | bat -l man -p ; }

# conventional commit selector
conventional_commit(){
	if ! is_git_repo; then { echo "not a git repo"; return }; fi

	local staged_files="$(git diff --name-only --cached)"
	if [[ -z "$staged_files" ]]; then { echo "no staged files to commit"; return }; fi

	local cc=("feat" "fix" "docs" "config" "refactor" "test" "build" "revert" "tag" "version")
	local choice=$(printf "%s\n" "${cc[@]}" | \
		fzf \
	    --ghost="select type" \
		--preview="git diff --stat --staged --format='%C(bold blue)%h%C(reset) - %C(green)%ar%C(reset): %C(cyan)%an%C(reset)%C(bold yellow)%d%C(reset)' --color=always" \
	)
	if [[ -z "$choice" ]]; then { echo "commit aborted"; return } fi
	local text=$(gum input --prompt="${choice}: " --placeholder="commit message...")
	if [[ -z "$text" ]]; then { echo "commit aborted"; return } fi
	local message="${choice}: ${text}" && [[ -z "$choice" ]] && local message=$text

	git commit -m $message && \
	REMOTE="$(git rev-parse --abbrev-ref --symbolic-full-name @{u})"
	[[ ! "$(git ls-remote --exit-code --heads origin $(git rev-parse --abbrev-ref HEAD))" ]] && { echo "no remote branch set"; return; }
	gum confirm "push to $REMOTE?" && gum spin --spinner dot --title "git push..." --show-output git push || echo "changes not pushed"
}

# amend commit
amend_commit(){
	if ! is_git_repo; then { echo "not a git repo"; return }; fi

	local staged_files="$(git diff --name-only --cached)"
	if [[ -z "$staged_files" ]]; then { echo "no staged files to commit"; return }; fi

	gum confirm "amend last commit?" && git commit --amend --no-edit
}

# json_diff
json_diff() {
	if [[ $# -eq 2 ]]; then
		delta =(jq -S . $1) =(jq -S . $2)
	else
		echo "expected two arguments"
	fi
}

# grep highlight with delta
gr() { rg "$@" -N --json | delta --tabs=1 | tail -n+2 | bat -p; }

# grep in json files with gron
jgr() {
	case $1 in
		-o)
			shift
			gron | rg "$1" | gron -u -m | jq;;
		*)
			gron "$2" | rg "$1" | gron -u -m | jq;;
	esac
}

# visualise todo file
todo() {
	local TODOFILE="${HOME}/.todo"
	if [[ -z "$1" ]]; then
		${EDITOR} ${TODOFILE}
	fi

	case $1 in
		-d)
			gum confirm "delete todo content?" && truncate -s 0 ${TODOFILE};;
	esac
}

# tag release version
tagme() {
	if ! is_git_repo; then { echo "not a git repo"; return }; fi
	
	local tc=("hotfix" "minor" "major")
	local choice=$(printf "%s\n" "${tc[@]}" | fzf --ghost="select type")
	if [[ -z "$choice" ]]; then { echo "tag aborted"; return } fi
	
	local latest_tag=$(git tag -l --sort=-v:refname | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+$' | head -n 1)
	if [[ -z "$latest_tag" ]]; then { echo "no version tags found"; return } fi
	
	local clean_version=${latest_tag#v}
	local parts=("${(@s/./)clean_version}")
	
	case $choice in
		"hotfix")
			local new_version="v${parts[1]}.${parts[2]}.$((parts[3] + 1))"
			;;
		"minor")
			local new_version="v${parts[1]}.$((parts[2] + 1)).0"
			;;
		"major")
			local new_version="v$((parts[1] + 1)).0.0"
			;;
	esac
	
	gum join --align left "Latest tag is " "$latest_tag" ". New version will be " "$new_version"
	if gum confirm ""; then
		local text=$(gum input --placeholder="tag description")
		if [[ -z "$text" ]]; then { echo "no tag description: aborted"; return } fi
		git tag -a "$new_version" -m "$text"
		if gum confirm "Push $new_version to remote?"; then
			gum spin --spinner dot --title "git push..." --show-output git push origin tag "$new_version" || echo "Failed to push tag."
		else
			echo "Push cancelled."
		fi
	else
		echo "No tag created."
	fi
}

# open neorg notes
neorg() {
	local NEORG_DIR="${HOME}/notes"
	if [[ -f "${NEORG_DIR}/index.norg" ]]; then
		cd "${NEORG_DIR}" && nvim index.norg
	else
		echo "No index.norg found in ${NEORG_DIR}"
	fi
}

# zellij session manager
zj() {
	if [[ -z "$1" ]]; then
		zellij
		return
	fi

	case $1 in
		-a)
			local session=$(zellij ls -s | fzf --ansi --ghost 'attach to session' --exit-0)
			[[ -n "$session" ]] && zellij attach "$session"
			;;
		-d)
			local session=$(zellij ls -s | fzf --ansi --ghost 'delete session' --exit-0)
			[[ -n "$session" ]] && gum confirm "delete $session?" && zellij delete-session "$session" -f
			;;
		*)
			echo "Usage: zj [-a|-d]"
			echo "  -a  attach to a zellij session"
			echo "  -d  delete a zellij session"
			;;
	esac
}
